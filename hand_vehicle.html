<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <title>画像処理レーシング</title>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
        <style type="text/css">
            html {
                font-size: 16px;
                background-color: #FFFFFF;
            }
            #canvas_wrapper {
                position: relative;
            }
            canvas {
                position: absolute;
                left: 0;
                right: 0;
                margin: auto;
            }
            .course {
                position: absolute;
                width: 30%;
                height: 10%;
                font-size: 3vw;
            }

        </style>
        <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
        <script src="js/bootstrap.min.js"></script>
        
        <!--<script src="js/opencv.js"></script>-->
        <script src="https://docs.opencv.org/master/opencv.js"></script>
        <script src="js/three.min.js"></script>
        <script src="js/ColladaLoader.js"></script>
        <script src="js/cannon.min.js"></script>
        
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.1.1617147326/hands.js" crossorigin="anonymous"></script>
    </head>
    <body>
        <div id="canvas_wrapper">
            <canvas id="canvas"></canvas>
            <canvas id="canvas2" style="transform: scale(-1, 1); opacity: 1.0;"></canvas>
            <canvas id="canvas3" style="opacity: 0.8;"></canvas>
            <button id="parking" type="button" style="top: 20%; left: 30%; width: 40%" class="btn btn-success course">Parking</button>
            <button id="course1" type="button" style="top: 30%; left: 30%;" class="btn btn-primary course">Course 1</button>
            <button id="course2" type="button" style="top: 40%; left: 35%;" class="btn btn-warning course">Course 2</button>
            <button id="course3" type="button" style="top: 50%; left: 40%;" class="btn btn-danger course">Course 3</button>
            <button id="restart" type="button" style="width: 16%; top: 56%; right: 0%; display: none;" class="btn btn-primary course">Restart</button>
        </div>
        <video id="video"></video>
        <div class="container-fluid">
            <div class="row">
              <div class="col-2"></div>
              <div class="col-8">
                <br>
                <h1>遊び方</h1>
                <center>
                    <video id="how_to_play" src="img/how_to_play.mp4" controls></video>
                </center>
                <br>
                <p>
                カメラの画像から両手の角度と手の大きさを検出し、車のハンドルとアクセルを操作します。<br>
                両手を傾けると連動してハンドルが傾き、手を広げる(あるいはカメラに近づける)と加速、手を握る(あるいはカメラから遠ざける)と減速します。
                </p>
                <p>
                Parking, Course 1~3のゲームモードがあります。<br>
                Parkingでは車を半透明のターゲットに合わせて駐車すること、Course 1~3では各コースに配置された赤色と青色のチェックポイントを全て通過することを目標とします。
                </p>
                <p>
                ※カメラを使用できるPCのChrome/Firefoxでの実行を推奨いたします。<br>
                ※PCの性能によって、動作が遅い場合があります。
                </p>
                <center>
                    <iframe src="https://docs.google.com/forms/d/e/1FAIpQLSephYXm6roopJ-jU5LDxg8tg-I65UAZJ92zN0rKepJuD3Ytxg/viewform?embedded=true" width="640" height="640" frameborder="0" marginheight="0" marginwidth="0">読み込んでいます…</iframe>
                </center>
              </div>
              <div class="col-2"></div>
            </div>
        </div>
        <script>
            let count = 0;
            let world;
            let timeStep = 1/20;
            // 物理エンジン上の平面、本体、車輪
            let phyPlane;
            let phyCar, phyBody, phyWheels = new Array(4);
            let checkNum = 8;
            let phyCheck = new Array(checkNum);
            let carSize = [35, 16, 16], phyBodySize = [24, 8, 8], wheelSize = [3.5, 2];
            // 前の車輪の本体に対する角度と車輪のスピード
            let wheelAngle = 0.5, wheelSpeed = 3;
            // 本体と車輪の拘束
            let constraints = [];
            let scene;
            // CG上の平面、本体、車輪
            let viewPlane;
            let viewBody, viewWheels = new Array(8);
            let viewCar;
            let targetPosition, targetDirection, targetBody, targetWheels = new Array(8), targetQuaternions = new Array(4);
            let targetRatio = 0;
            let viewCheck = new Array(checkNum);
            let renderer;
            let canvas = document.getElementById("canvas");
            let canvas2 = document.getElementById("canvas2");
            let context2 = canvas2.getContext("2d");
            let canvas3 = document.getElementById("canvas3");
            let container = document.getElementById("container");
            let loader = new THREE.ColladaLoader();

            let textureFile;
            let planeSize;
            let carPosition;
            let CheckPosition;
            let carMode = 0;
            let speedUp = 0;

            let handleImg = new Image();
            handleImg.src = "img/handle.png";
            let course1Img = new Image();
            course1Img.src = "img/Course1.png";
            let course2Img = new Image();
            course2Img.src = "img/Course2.png";
            let course3Img = new Image();
            course3Img.src = "img/Course3.png";
            let area1Img = new Image();
            area1Img.src = "img/Area1.png";
            let area2Img = new Image();
            area2Img.src = "img/Area2.png";
            let area3Img = new Image();
            area3Img.src = "img/Area3.png";
            let carImg = new Image();
            carImg.src = "img/Car.png";
            let redImg = new Image();
            redImg.src = "img/Red.png";
            let blueImg = new Image();
            blueImg.src = "img/Blue.png";

            function clamp(x, l, h){
                return Math.min(Math.max(l, x), h);
            }

            // ウィンドウの大きさが変わったとき、描画範囲も変更
            function onWindowResize(){
                if (innerWidth < innerHeight*16/9){
                    canvas.width = innerWidth;
                    canvas.height = canvas.width*9/16;
                    canvas2.width = canvas.width;
                    canvas2.height = canvas.height;
                    canvas3.width = canvas.width;
                    canvas3.height = canvas.height;
                }
                else {
                    canvas.height = innerHeight;
                    canvas.width = canvas.height*16/9;
                    canvas2.width = canvas.width;
                    canvas2.height = canvas.height;
                    canvas3.width = canvas.width;
                    canvas3.height = canvas.height;
                }
                if (renderer != undefined){
                    renderer.setSize(canvas.width, canvas.height);
                }
                document.getElementById("canvas_wrapper").style.height = String(canvas.height+10)+"px";
                document.getElementById("restart").style.right = String(canvas.offsetLeft)+"px";
                document.getElementById("how_to_play").width = canvas.width*0.5;
            }
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize();

            let mode, operation=false;
            document.getElementById("parking").onclick = () => {
                mode = 0;
                checkNum = 0;
                start();
            };
            document.getElementById("course1").onclick = () => {
                mode = 1;
                checkNum = 4;
                start();
            };
            document.getElementById("course2").onclick = () => {
                mode = 2;
                checkNum = 5;
                start();
            };
            document.getElementById("course3").onclick = () => {
                mode = 3;
                checkNum = 6;
                start();
            };
            document.getElementById("restart").onclick = () => {
                restart();
            };

            function start(){
                document.getElementById("parking").style.display = "none";
                document.getElementById("course1").style.display = "none";
                document.getElementById("course2").style.display = "none";
                document.getElementById("course3").style.display = "none";
                document.getElementById("restart").style.display = "";
                setPhy();
                setView();
                if (mode == 0)    createTarget();
                animate();
            }

            function restart(){
                location.reload(false);
            }

            if (navigator.userAgent.match(/iPhone|Android.+Mobile/) && false){
                if (typeof DeviceMotionEvent.requestPermission === 'function'){
                    (async () => await DeviceMotionEvent.requestPermission())();
                }
                timeStep = 1/30;
                window.addEventListener("devicemotion", e => {
                    let accVec = e.accelerationIncludingGravity;
                    let [x, y, z] = [accVec.x, accVec.y, accVec.z];
                    let angle = Math.atan(y/x);
                    wheelAngle = -4*angle;
                    wheelSpeed = z;
                });
                operation = true;
            }
            else {
                const video = document.getElementById("video");
                video.style.display = "none";

                function onResults(results) {
                    operation = true;
                    let width = canvas2.width;
                    let height = canvas2.height;
                    let img = new cv.Mat(height, width, cv.CV_8UC4);
                    context2.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, width, height);
                    img.data.set(context2.getImageData(0, 0, width, height).data);
                    context2.clearRect(0, 0, width, height);
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length == 2) {
                        let sumx = [0, 0], sumy = [0, 0], avgx = [0, 0], avgy = [0, 0];
                        results.multiHandLandmarks.forEach((landmarks, index) => {
                            landmarks.forEach(point => {
                                p = new cv.Point(width*point.x, height*point.y);
                                cv.circle(img, p, width/100, [255, 0, 0, 255], cv.FILLED);
                                // 手の中心点を求める。
                                const {x, y} = point;
                                sumx[index] = sumx[index] + width*x;
                                sumy[index] = sumy[index] + height*y;
                            });
                            avgx[index] = Math.floor(sumx[index] / landmarks.length);
                            avgy[index] = Math.floor(sumy[index] / landmarks.length);
                            let avgp = new cv.Point(avgx[index], avgy[index])
                            cv.circle(img, avgp, width/100, [0, 0, 255, 255], cv.FILLED);
                        });
                        // 中心との角度計算
                        let center = [(avgx[0]+avgx[1])/2, (avgy[0]+avgy[1])/2];
                        let angle;
                        if (avgx[0] > avgx[1]){
                            angle = Math.atan2(avgy[0] - center[1], avgx[0] - center[0]);
                        }
                        else {
                            angle = Math.atan2(avgy[1] - center[1], avgx[1] - center[0]);
                        }
                        let handSize = 0;
                        let diff = (x1, y1, x2, y2) => {return ((x1-x2)**2+(y1-y2)**2)**0.5};
                        results.multiHandLandmarks.forEach((landmarks, index) => {
                            landmarks.forEach(point => {
                                handSize = Math.max(handSize, diff(avgx[index], avgy[index], width*point.x, height*point.y));
                            });
                        });
                        let maxSpeed = 5;
                        if (carMode == 0){
                            wheelAngle = angle/2;
                            wheelSpeed = clamp(70*(handSize/width-0.12), -maxSpeed, maxSpeed);
                        }
                        else if (carMode == 1){
                            wheelAngle = angle/2;
                            wheelSpeed = clamp(70*(handSize/width-0.12), -maxSpeed, maxSpeed);
                            /*
                            phyBody.velocity.normalize();
                            phyBody.velocity = phyBody.velocity.scale(20);
                            for (let i=0; i<4; i++){
                                phyWheels[i].velocity.normalize();
                                phyWheels[i].velocity = phyWheels[i].velocity.scale(20);
                            }
                            */
                        }
                        else if (carMode == 2){
                            wheelAngle = angle/2;
                            wheelSpeed = clamp(70*(handSize/width-0.12), -maxSpeed/2, maxSpeed/2);
                        }
                        else if (carMode == 3){
                            wheelAngle = clamp(angle/2, -0.75, 0.75);
                            wheelSpeed = clamp(70*(handSize/width-0.12), -maxSpeed, maxSpeed);
                            phyBody.angularVelocity = new CANNON.Vec3(0, angle*Math.sign(wheelSpeed), 0);
                        }
                        if (Date.now()-speedUp < 3000){
                            wheelSpeed *= 2;
                        }
                    }
                    else {
                        wheelAngle *= 0.95;
                        wheelSpeed *= 0.95;
                    }
                    let M = cv.matFromArray(2, 3, cv.CV_64FC1, [1/3, 0, 0, 0, 1/3, height*2/3]);
                    let dsize = new cv.Size(width, height);
                    cv.warpAffine(img, img, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                    
                    let handle = cv.imread(handleImg);
                    cv.resize(handle, handle, new cv.Size(height/3, height/3));
                    M = cv.getRotationMatrix2D(new cv.Point(height/6, height/6), -wheelAngle*360/Math.PI, 1);
                    cv.warpAffine(handle, handle, M, new cv.Size(height/3, height/3), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                    let roi = img.roi(new cv.Rect(width*2/3-height/3, height*2/3, height/3, height/3));
                    handle.copyTo(roi);
                    roi.delete();

                    if (mode > 0){
                        let img2 = new cv.Mat(height, width, cv.CV_8UC4, new cv.Scalar());
                        let course = cv.imread([course1Img, course2Img, course3Img][mode-1]);
                        let area = cv.imread([area1Img, area2Img, area3Img][mode-1]);
                        //cv.cvtColor(area, area, cv.COLOR_BGR2HSV);
                        cv.resize(course, course, new cv.Size(height/3, height/3));
                        M = cv.getRotationMatrix2D(new cv.Point(height/6, height/6), 90, 1);
                        cv.warpAffine(course, course, M, new cv.Size(height/3, height/3), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                        roi = img2.roi(new cv.Rect(height/3*(3.5/9), height*2/3, height/3, height/3));
                        course.copyTo(roi);
                        roi.delete();
                        course.delete();

                        let carSize = height/3*50/planeSize;

                        function paste(src, dst, x, y){
                            for (let i=0; i<src.rows; i++){
                                for (let j=0; j<src.cols; j++){
                                    if (src.ucharPtr(i, j)[3] != 0){
                                        dst.ucharPtr(y+i, x+j)[0] = src.ucharPtr(i, j)[0];
                                        dst.ucharPtr(y+i, x+j)[1] = src.ucharPtr(i, j)[1];
                                        dst.ucharPtr(y+i, x+j)[2] = src.ucharPtr(i, j)[2];
                                    }
                                }
                            }
                        }

                        let checkSize = carSize*0.6;
                        let red = cv.imread(redImg);
                        cv.resize(red, red, new cv.Size(checkSize, checkSize));
                        for (let i=0; i<checkNum-1; i++){
                            if (viewCheck[i].visible){
                                paste(red, img2, height/3*(CheckPosition[i][1]/planeSize+0.5+3.5/9)-checkSize/2, height-height/3*(CheckPosition[i][0]/planeSize+0.5)-checkSize/2);
                            }
                        }
                        red.delete();
                        if (viewCheck[checkNum-1].visible){
                            let blue = cv.imread(blueImg);
                            cv.resize(blue, blue, new cv.Size(checkSize, checkSize));
                            paste(blue, img2, height/3*(CheckPosition[checkNum-1][1]/planeSize+0.5+3.5/9)-checkSize/2, height-height/3*(CheckPosition[checkNum-1][0]/planeSize+0.5)-checkSize/2);
                            blue.delete();
                        }

                        let x, y;
                        x = viewCar.position.z/planeSize+0.5;
                        y = -viewCar.position.x/planeSize+0.5;
                        if (0 < x && x < 1 && 0 < y && y < 1){
                            carMode = area.ucharPtr(x*area.rows, (1-y)*area.cols);
                            if (carMode[0] == 255){
                                carMode = 1;
                                speedUp = Date.now();
                            }
                            else if (carMode[1] == 255){
                                carMode = 2;
                            }
                            else if (carMode[2] == 255){
                                carMode = 3;
                            }
                            else {
                                carMode = 0;
                            }
                        }
                        else {
                            carMode = 2;
                        }
                        area.delete();

                        if (Date.now()-speedUp < 3000){
                            for (let i=4; i<8; i++){
                                viewWheels[i].material.color.set(0xffff00);
                            }
                        }
                        else if (carMode == 0){
                            for (let i=4; i<8; i++){
                                viewWheels[i].material.color.set(0xaaaaaa);
                            }
                        }
                        else if (carMode == 2){
                            for (let i=4; i<8; i++){
                                viewWheels[i].material.color.set(0x33aa33);
                            }
                        }
                        else if (carMode == 3){
                            for (let i=4; i<8; i++){
                                viewWheels[i].material.color.set(0x00bbbb);
                            }
                        }

                        let forward = new THREE.Vector4(1, 0, 0, 0);
                        forward.applyMatrix4(viewCar.matrix).normalize();
                        let carAngle = Math.atan2(-forward.z, forward.x);
                        let car = cv.imread(carImg);
                        cv.resize(car, car, new cv.Size(carSize, carSize));
                        M = cv.getRotationMatrix2D(new cv.Point(carSize/2, carSize/2), carAngle*180/Math.PI-90, 1);
                        cv.warpAffine(car, car, M, new cv.Size(carSize, carSize), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                        //roi = img.roi(new cv.Rect(height/3*(x+3.5/9), height*(2/3+y/3), carSize, carSize));
                        paste(car, img2, height/3*(x+3.5/9)-carSize/2, height*(2/3+y/3)-carSize/2);
                        car.delete();
                        
                        cv.imshow("canvas3", img2);
                        img2.delete();
                    }

                    let speed = clamp(-wheelSpeed/5, -1, 1);
                    let color = (speed => {
                        if (speed < -0.5)        return [255, speed*512+512, 0, 255];
                        else if (speed < 0)      return [-speed*512, 255, 0, 255];
                        else if (speed < 0.5)    return [0, 255, speed*512, 255];
                        else                     return [0, -speed*512+512, 255, 255];
                    })(speed);
                    cv.rectangle(img, new cv.Point(width*(17/48), height*(5/6+speed/6-0.01)), new cv.Point(width*(22/48), height*(5/6+speed/6+0.01)), color, cv.FILLED);
                    cv.ellipse(img, new cv.Point(width*(40/48), height*(5/6)), new cv.Size(height/6, height/6), 0, 270-targetRatio, 270, [0, 0, 255, 255], cv.FILLED);
                    cv.imshow("canvas2", img);
                    img.delete();
                    handle.delete();
                }

                const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.1.1617147326/${file}`;
                }});
                hands.setOptions({
                    maxNumHands: 2,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                hands.onResults(onResults);

                let flag = 0;
                const cameraDevice = new Camera(video, {
                    onFrame: async () => {
                        flag++;
                        if (flag%10 == 0){
                            await hands.send({image: video});
                        }
                    },
                    width: 1280,
                    height: 720
                });
                cameraDevice.start();
            }

            // 物理エンジンの設定
            function setPhy() {
                wheelAngle = 0;
                wheelSpeed = 0;
                // 物理世界を生成
                world = new CANNON.World();
                // 重力を設定
                world.gravity.set(0, -9.82, 0);
                // ぶつかっている「可能性のある」剛体同士を見つける作業
                world.broadphase = new CANNON.NaiveBroadphase();
                // 反復計算回数
                world.solver.iterations = 10;
                // 許容値
                world.solver.tolerance = 0.1;

                let mat = new CANNON.Material('mat');
                mat.friction = 1.0;
                mat.restitution = 0.5;

                // 地面用にPlaneの剛体を質量0で生成
                phyPlane = new CANNON.Body({mass: 0});
                phyPlane.material = mat;
                phyPlane.addShape(new CANNON.Plane());
                // X軸に90度に回転
                phyPlane.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);
                // 物理世界に追加
                world.add(phyPlane);

                // Boxのシェイプの剛体を質量10で生成
                phyBody = new CANNON.Body({mass: 10});
                phyBody.material = mat;
                phyBody.addShape(new CANNON.Box(new CANNON.Vec3(phyBodySize[0]/2, phyBodySize[1]/2, phyBodySize[2]/2)));
                phyBody.position.y = 10;
                // 物理世界に追加
                world.add(phyBody);

                phyCar = new CANNON.Body({
                    mass: 10,
                    collisionFilterGroup: 2,
                    collisionFilterMask: 2
                });
                phyCar.material = mat;
                phyCar.addShape(new CANNON.Box(new CANNON.Vec3(carSize[0]/2, carSize[1]/2, carSize[2]/2)));
                phyCar.position.y = 10;
                // 物理世界に追加
                world.add(phyCar);

                // 車輪の生成
                // 0: 前左, 1: 前右
                // 2: 後左, 3: 後右
                for (var i=0; i<4; i++){
                    phyWheels[i] = new CANNON.Body({mass: 1});
                    phyWheels[i].mat = mat;
                    phyWheels[i].addShape(new CANNON.Cylinder(wheelSize[0], wheelSize[0], wheelSize[1], 100));
                    if (i < 2)    phyWheels[i].position.x = phyBodySize[0]/2-wheelSize[0]/2;
                    else          phyWheels[i].position.x = -(phyBodySize[0]/2-wheelSize[0]/2);
                    phyWheels[i].position.y = 10-phyBodySize[1]/2+wheelSize[0]/2;
                    if (i%2 == 0)    phyWheels[i].position.z = -(phyBodySize[2]/2+wheelSize[1]/2+2);
                    else             phyWheels[i].position.z = phyBodySize[2]/2+wheelSize[1]/2+2;
                    world.add(phyWheels[i]);
                }

                // 本体と車輪の拘束を設定
                let zero = new CANNON.Vec3();
                constraints.push(new CANNON.HingeConstraint(phyBody, phyWheels[0],  {pivotA: new CANNON.Vec3(phyBodySize[0]/2-wheelSize[0]/2, -phyBodySize[1]/2+wheelSize[0]/2, -(phyBodySize[2]/2+wheelSize[1]/2+2)), axisA: new CANNON.Vec3(0, 0, 1),  pivotB: zero, axisB: new CANNON.Vec3(0, 0, 1)}));
                constraints.push(new CANNON.HingeConstraint(phyBody, phyWheels[1],  {pivotA: new CANNON.Vec3(phyBodySize[0]/2-wheelSize[0]/2, -phyBodySize[1]/2+wheelSize[0]/2, phyBodySize[2]/2+wheelSize[1]/2+2), axisA: new CANNON.Vec3(0, 0, 1),  pivotB: zero, axisB: new CANNON.Vec3(0, 0, 1)}));
                constraints.push(new CANNON.HingeConstraint(phyBody, phyWheels[2],  {pivotA: new CANNON.Vec3(-(phyBodySize[0]/2-wheelSize[0]/2), -phyBodySize[1]/2+wheelSize[0]/2, -(phyBodySize[2]/2+wheelSize[1]/2+2)), axisA: new CANNON.Vec3(0, 0, 1),  pivotB: zero, axisB: new CANNON.Vec3(0, 0, 1)}));
                constraints.push(new CANNON.HingeConstraint(phyBody, phyWheels[3],  {pivotA: new CANNON.Vec3(-(phyBodySize[0]/2-wheelSize[0]/2), -phyBodySize[1]/2+wheelSize[0]/2, phyBodySize[2]/2+wheelSize[1]/2+2), axisA: new CANNON.Vec3(0, 0, 1),  pivotB: zero, axisB: new CANNON.Vec3(0, 0, 1)}));
                for (let i=0; i<4; i++){
                    world.addConstraint(constraints[i]);
                }
                // 前輪で駆動
                constraints[0].enableMotor();
                constraints[1].enableMotor();

                if (mode != 0){
                    for (let i=0; i<checkNum; i++){
                        phyCheck[i] = new CANNON.Body({
                            mass: 0,
                            collisionFilterGroup: 2,
                            collisionFilterMask: 2
                        });
                        phyCheck[i].mat =  mat;
                        phyCheck[i].addShape(new CANNON.Sphere(4));
                        phyCheck[i].collisionResponse = 0;
                        world.add(phyCheck[i]);
                        phyCheck[i].addEventListener("collide", e => {
                            let flag = -1;
                            for (let i=0; i<checkNum; i++){
                                if (e.body.id == phyCheck[i].id || e.target.id == phyCheck[i].id){
                                    flag = i;
                                    break;
                                }
                            }
                            if (flag != -1){
                                viewCheck[flag].visible = false;
                            }
                        });
                    }
                }
            }

            // CGの設定
            function setView() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(45, canvas.width/canvas.height, 0.1, 1000);
                camera.position.set(-60, 60, -60);
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                scene.add(camera);

                let directionalLight = new THREE.DirectionalLight(0xffffff);
                directionalLight.position.set(-100, 100, 100);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.set(4096, 4096);
                directionalLight.shadow.camera.near = 2;
                directionalLight.shadow.camera.far = 10000;
                directionalLight.shadow.camera.left = -500;
                directionalLight.shadow.camera.right = 500;
                directionalLight.shadow.camera.top = 500;
                directionalLight.shadow.camera.bottom = -500;
                scene.add(directionalLight);
                
                let amb = new THREE.AmbientLight(0x999999);
                scene.add(amb);

                loader.load('./img/Car.dae', (collada) => {
                    viewCar = collada.scene;
                    viewCar.scale.set(8, 8, 8);
                    viewCar.traverse(function(child) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    });
                    for (let i=0; i<collada.scene.children[0].material.length; i++){
                        collada.scene.children[0].material[i].type = "MeshPhongMaterial";
                    }
                    scene.add(viewCar);
                });

                for (var i=0; i<4; i++){
                    let geoWheel = new THREE.CylinderGeometry(wheelSize[0], wheelSize[0], wheelSize[1], 100);
                    geoWheel.rotateX(Math.PI/2);
                    viewWheels[i] = new THREE.Mesh(geoWheel, new THREE.MeshLambertMaterial({
                        color: 0x000000
                    }));
                    viewWheels[i].castShadow = true;
                    viewWheels[i].receiveShadow = true;
                    scene.add(viewWheels[i]);

                    geoWheel = new THREE.CylinderGeometry(0.6*wheelSize[0], 0.6*wheelSize[0], wheelSize[1]*1.1, 100);
                    geoWheel.rotateX(Math.PI/2);
                    viewWheels[i+4] = new THREE.Mesh(geoWheel, new THREE.MeshLambertMaterial({
                        color: 0xaaaaaa
                    }));
                    viewWheels[i+4].castShadow = true;
                    viewWheels[i+4].receiveShadow = true;
                    scene.add(viewWheels[i+4]);
                }

                /*
                viewBody = new THREE.Mesh(new THREE.CubeGeometry(phyBodySize[0], phyBodySize[1], phyBodySize[2], 10, 10), new THREE.MeshLambertMaterial({
                    color: 0xff00ff
                }));
                viewBody.castShadow = true;
                viewBody.receiveShadow = true;
                scene.add(viewBody);
                */

                if (mode == 0){
                    loader.load('./img/Car.dae', (collada) => {
                        targetBody = collada.scene;
                        targetBody.scale.set(8, 8, 8);
                        for (let i=0; i<collada.scene.children[0].material.length; i++){
                            collada.scene.children[0].material[i].opacity = 0.5;
                            collada.scene.children[0].material[i].transparent = true;
                        }
                        scene.add(targetBody);
                    });
                    /*
                    targetBody = new THREE.Mesh(new THREE.CubeGeometry(phyBodySize[0], phyBodySize[1], phyBodySize[2], 10, 10), new THREE.MeshLambertMaterial({
                        color: 0xff00ff,
                        opacity: 0.5,
                        transparent: true
                    }));
                    scene.add(targetBody);
                    */
                    for (var i=0; i<4; i++){
                        let geoWheel = new THREE.CylinderGeometry(wheelSize[0], wheelSize[0], wheelSize[1], 100);
                        geoWheel.rotateX(Math.PI/2);
                        targetWheels[i] = new THREE.Mesh(geoWheel, new THREE.MeshLambertMaterial({
                            color: 0x000000,
                            opacity: 0.5,
                            transparent: true
                        }));
                        scene.add(targetWheels[i]);

                        geoWheel = new THREE.CylinderGeometry(0.6*wheelSize[0], 0.6*wheelSize[0], wheelSize[1]*1.1, 100);
                        geoWheel.rotateX(Math.PI/2);
                        targetWheels[i+4] = new THREE.Mesh(geoWheel, new THREE.MeshLambertMaterial({
                            color: 0xaaaaaa,
                            opacity: 0.5,
                            transparent: true
                        }));
                        scene.add(targetWheels[i+4]);
                    }
                }

                textureFile = ["img/check.png", "img/Course1.png", "img/Course2.png", "img/Course3.png"][mode];
                planeSize = [80, 250, 300, 400][mode];
                carPosition = [[0, 0], [-102, -85], [-130, -109], [-176, -158]][mode];
                CheckPosition = [undefined,
                    [[-14, -82], [82, -82], [82, 18], [82, 100]],
                    [[-42, -109], [55, -55], [-133, 0], [39, 93], [-133, 109]],
                    [[15, -156], [76, -82], [4, -29], [-83, 67], [107, 67], [177, 160]]
                ][mode];
                phyBody.position.vadd(new CANNON.Vec3(carPosition[0], 0, carPosition[1]), phyBody.position);
                for (let i=0; i<4; i++){
                    phyWheels[i].position.vadd(new CANNON.Vec3(carPosition[0], 0, carPosition[1]), phyWheels[i].position);
                }
                for (let i=0; i<checkNum; i++){
                    phyCheck[i].position.set(CheckPosition[i][0], 0, CheckPosition[i][1]);
                }

                let texture = new THREE.TextureLoader().load(textureFile);
                viewPlane = new THREE.Mesh(new THREE.PlaneGeometry(planeSize, planeSize), new THREE.MeshPhongMaterial({
                    map: texture
                }));
                viewPlane.rotation.x = -Math.PI/2;
                viewPlane.receiveShadow = true;
                scene.add(viewPlane);

                if (mode != 0){
                    for (let i=0; i<checkNum; i++){
                        loader.load('./img/CheckPoint.dae', (collada) => {
                            viewCheck[i] = collada.scene;
                            viewCheck[i].scale.set(0.1, 0.1, 0.1);
                            viewCheck[i].traverse(function(child) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            });
                            collada.scene.children[0].material = new THREE.MeshStandardMaterial({
                                color: (i != checkNum-1 ? 0xff0000 : 0x0040ff),
                                roughness: 0.8,
                                metalness: 0.2,
                                opacity: 0.7,
                                transparent: true
                            });
                            scene.add(viewCheck[i]);
                        });
                    }
                }
                
                renderer = new THREE.WebGLRenderer({canvas: canvas});
                renderer.setSize(canvas.width, canvas.height);
                renderer.setClearColor(0x87ceeb);
                renderer.shadowMap.enabled = true;
                renderer.render(scene, camera);
            }
            
            // 手の検出
            // 物理エンジンを1ステップ進める→CGに反映
            // を繰り返す
            function animate(){
                count++;
                if (document.getElementById("restart").style.display != "none"){
                    setTimeout(animate, 20);
                }
                //requestAnimationFrame(animate);
                // 物理エンジンの時間を進める
                if (operation)    world.step(timeStep);
                
                /*
                viewBody.position.copy(phyBody.position);
                viewBody.quaternion.copy(phyBody.quaternion);
                */

                phyCar.position.copy(phyBody.position);
                phyCar.quaternion.copy(phyBody.quaternion);
                
                viewCar.position.copy(phyBody.position);
                viewCar.quaternion.copy(phyBody.quaternion);

                let rot = new THREE.Quaternion();
                rot.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI/2);
                viewCar.quaternion.multiply(rot);
                rot.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI/2);
                viewCar.quaternion.multiply(rot);
                viewCar.position.add(new THREE.Vector3(0, -5, 0));
                
                for (let i=0; i<4; i++){
                    viewWheels[i].position.copy(phyWheels[i].position);
                    viewWheels[i].quaternion.copy(phyWheels[i].quaternion);
                    viewWheels[i+4].position.copy(phyWheels[i].position);
                    viewWheels[i+4].quaternion.copy(phyWheels[i].quaternion);
                }
                
                if (mode != 0){
                    for (let i=0; i<checkNum; i++){
                        viewCheck[i].position.copy(phyCheck[i].position);
                        if (operation){
                            rot = new THREE.Quaternion();
                            rot.setFromAxisAngle(new THREE.Vector3(0, 0, 1), 0.05);
                            viewCheck[i].quaternion.multiply(rot);
                        }
                    }
                }
                else {
                    let maxDist = 0;
                    for (let i=0; i<4; i++){
                        maxDist = Math.max(maxDist, ((x1, y1, x2, y2) => {
                            return ((x1-x2)**2+(y1-y2)**2)**0.5;
                        })(viewWheels[i].position.x, viewWheels[i].position.z, targetWheels[i].position.x, targetWheels[i].position.z));
                    }
                    targetRatio += Math.floor(20/maxDist);
                    if (targetRatio > 360){
                        targetRatio = 0;
                        createTarget();
                    }
                }

                // 前方ベクトルの計算
                let forward = new THREE.Vector4(1, 0, 0, 0);
                forward.applyMatrix4(viewCar.matrix).normalize();

                /*
                let ratio = 0.9;
                camera.position.multiplyScalar(ratio);
                camera.position.add(viewCar.position.clone().add(new THREE.Vector3(-80*forward.x, 50, -80*forward.z)).multiplyScalar(1-ratio));
                */
                camera.position.set(viewCar.position.x-60, viewCar.position.y+60, viewCar.position.z-60);
                camera.lookAt(viewCar.position);
                
                // 前輪で操舵
                constraints[0].axisA = new CANNON.Vec3(Math.sin(wheelAngle), 0, Math.cos(wheelAngle));
                constraints[1].axisA = new CANNON.Vec3(Math.sin(wheelAngle), 0, Math.cos(wheelAngle));
                constraints[0].setMotorSpeed(wheelSpeed);
                constraints[1].setMotorSpeed(wheelSpeed);
                // レンダリング
                renderer.render(scene, camera);
            }

            function createTarget(){
                if (targetBody == undefined){
                    setTimeout(100, createTarget);
                    return;
                }

                targetPosition = [10*Math.floor(Math.random()*7)-30, 10*Math.floor(Math.random()*7)-30];
                targetDirection = Math.floor(Math.random()*4);
                targetBody.position.set(targetPosition[0], phyBodySize[1]/2+wheelSize[0]/2, targetPosition[1]);
                
                let rot = new THREE.Quaternion();
                if (targetQuaternions[0] == undefined){
                    for (let i=0; i<4; i++){
                        rot.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI/2);
                        targetBody.quaternion.multiply(rot);
                        targetQuaternions[i] = targetBody.quaternion.clone();
                    }
                }
                targetBody.quaternion.copy(targetQuaternions[targetDirection]);
                targetBody.position.add(new THREE.Vector3(0, -5, 0));

                for (let i=0; i<4; i++){
                    if (targetDirection%2 == 1){
                        targetWheels[i].rotation.set(0, Math.PI/2, 0);
                    }
                    else {
                        targetWheels[i].rotation.set(0, 0, 0);
                    }
                    if (i < 2)    targetWheels[i].position.x = phyBodySize[0]/2-wheelSize[0]/2;
                    else          targetWheels[i].position.x = -(phyBodySize[0]/2-wheelSize[0]/2);
                    if (i%2 == 0)    targetWheels[i].position.z = -(phyBodySize[2]/2+wheelSize[1]/2+2);
                    else             targetWheels[i].position.z = phyBodySize[2]/2+wheelSize[1]/2+2;
                    if (targetDirection == 1){
                        [targetWheels[i].position.x, targetWheels[i].position.z] = [targetWheels[i].position.z, -targetWheels[i].position.x]
                    }
                    else if (targetDirection == 2){
                        targetWheels[i].position.x = -targetWheels[i].position.x;
                        targetWheels[i].position.z = -targetWheels[i].position.z;
                    }
                    else if (targetDirection == 3){
                        [targetWheels[i].position.x, targetWheels[i].position.z] = [-targetWheels[i].position.z, targetWheels[i].position.x]
                    }
                    targetWheels[i].position.add(targetBody.position);
                    targetWheels[i].position.y = wheelSize[0];

                    targetWheels[i+4].position.copy(targetWheels[i].position);
                    targetWheels[i+4].quaternion.copy(targetWheels[i].quaternion);
                }
            }
        </script>
    </body>
</html>