<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <title>画像処理レーシング</title>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
        <style type="text/css">
            html {
                font-size: 16px;
                background-color: #FFFFFF;
            }
            #canvas_wrapper {
                position: relative;
            }
            canvas {
                position: absolute;
                left: 0;
                right: 0;
                margin: auto;
            }
            .course {
                position: absolute;
                width: 30%;
                height: 10%;
                font-size: 3vw;
            }

        </style>
        <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
        <script src="js/bootstrap.min.js"></script>
        
        <!--<script src="js/opencv.js"></script>-->
        <script src="https://docs.opencv.org/master/opencv.js"></script>
        <script src="js/three.min.js"></script>
        <script src="js/ColladaLoader.js"></script>
        <script src="js/cannon.min.js"></script>
        
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.1.1617147326/hands.js" crossorigin="anonymous"></script>
    </head>
    <body>
        <div id="canvas_wrapper">
            <canvas id="canvas"></canvas>
            <canvas id="canvas2" style="transform: scale(-1, 1); opacity: 1.0;"></canvas>
            <canvas id="canvas3" style="opacity: 0.8;"></canvas>
            <button id="parking" type="button" style="top: 20%; left: 30%; width: 40%" class="btn btn-success course">Parking</button>
            <button id="course1" type="button" style="top: 30%; left: 30%;" class="btn btn-primary course">Course 1</button>
            <button id="course2" type="button" style="top: 40%; left: 35%;" class="btn btn-warning course">Course 2</button>
            <button id="course3" type="button" style="top: 50%; left: 40%;" class="btn btn-danger course">Course 3</button>
            <button id="restart" type="button" style="width: 16%; top: 56%; right: 0%; display: none; opacity: 0.8;" class="btn btn-primary course">Reload</button>
            <button id="time" type="button" style="width: 20%; top: 0%; left: 0%; display: none; opacity: 0.8;" class="btn btn-info course">Time: </button>
            <button id="min" type="button" style="width: 20%; top: 10%; left: 0%; display: none; opacity: 0.8;" class="btn btn-info course">Min : </button>
            <button id="mean" type="button" style="width: 20%; top: 20%; left: 0%; display: none; opacity: 0.8;" class="btn btn-info course">Mean: </button>
            <button id="reset" type="button" style="width: 20%; top: 30%; left: 0%; display: none; opacity: 0.8;" class="btn btn-danger course">Reset data</button>
            <button id="loading" type="button" style="width: 40%; top: 80%; left: 30%; opacity: 0.5;" class="btn btn-dark course">Loading...</button>
        </div>
        <video id="video"></video>
        <script>
            let time = 0;
            let world;
            let timeStep = 1/20;
            let localData = new Array(100);
            // 物理エンジン上の平面、本体、車輪
            let phyPlane;
            let phyCar, phyBody, phyWheels = new Array(4);
            let initBodyPosition = new CANNON.Vec3(), initBodyQuaternion = new CANNON.Quaternion();
            let initWheelPosition = new Array(4), initWheelQuaternion = new Array(4);
            for (let i=0; i<4; i++){
                initWheelPosition[i] = new CANNON.Vec3();
                initWheelQuaternion[i] = new CANNON.Quaternion();
            }
            let checkNum = 8;
            let phyCheck = new Array(checkNum);
            let carSize = [35, 16, 16], phyBodySize = [24, 8, 8], wheelSize = [3.5, 2];
            // 前の車輪の本体に対する角度と車輪のスピード
            let wheelAngle = 0.5, wheelSpeed = 3;
            // 本体と車輪の拘束
            let constraints = [];
            let scene;
            // CG上の平面、本体、車輪
            let viewPlane;
            let viewBody, viewWheels = new Array(8);
            let viewCar;
            let targetPosition, targetDirection, targetBody, targetWheels = new Array(8), targetQuaternions = new Array(4);
            let targetRatio = 0;
            let viewCheck = new Array(checkNum);
            let renderer;
            let canvas = document.getElementById("canvas");
            let canvas2 = document.getElementById("canvas2");
            let context2 = canvas2.getContext("2d");
            let canvas3 = document.getElementById("canvas3");
            let container = document.getElementById("container");
            let loader = new THREE.ColladaLoader();

            let textureFile;
            let planeSize;
            let carPosition;
            let CheckPosition;
            let carMode = 0;
            let speedUp = 0;

            let img, handle, rotHandle, course, area, red, blue;

            let handleImg = new Image();
            handleImg.src = "img/handle.png";
            let course1Img = new Image();
            course1Img.src = "img/Course1.png";
            let course2Img = new Image();
            course2Img.src = "img/Course2.png";
            let course3Img = new Image();
            course3Img.src = "img/Course3.png";
            let area1Img = new Image();
            area1Img.src = "img/Area1.png";
            let area2Img = new Image();
            area2Img.src = "img/Area2.png";
            let area3Img = new Image();
            area3Img.src = "img/Area3.png";
            let carImg = new Image();
            carImg.src = "img/Car.png";
            let redImg = new Image();
            redImg.src = "img/Red.png";
            let blueImg = new Image();
            blueImg.src = "img/Blue.png";

            function clamp(x, l, h){
                return Math.min(Math.max(l, x), h);
            }

            // ウィンドウの大きさが変わったとき、描画範囲も変更
            function onWindowResize(){
                if (innerWidth < innerHeight*16/9){
                    canvas.width = innerWidth;
                    canvas.height = canvas.width*9/16;
                    canvas2.width = canvas.width;
                    canvas2.height = canvas.height;
                    canvas3.width = canvas.width;
                    canvas3.height = canvas.height;
                }
                else {
                    canvas.height = innerHeight;
                    canvas.width = canvas.height*16/9;
                    canvas2.width = canvas.width;
                    canvas2.height = canvas.height;
                    canvas3.width = canvas.width;
                    canvas3.height = canvas.height;
                }
                if (renderer != undefined){
                    renderer.setSize(canvas.width, canvas.height);
                }
                document.getElementById("canvas_wrapper").style.height = String(canvas.height+10)+"px";
                document.getElementById("restart").style.right = String(canvas.offsetLeft)+"px";
                document.getElementById("time").style.left = String(canvas.offsetLeft)+"px";
                document.getElementById("min").style.left = String(canvas.offsetLeft)+"px";
                document.getElementById("mean").style.left = String(canvas.offsetLeft)+"px";
                document.getElementById("reset").style.left = String(canvas.offsetLeft)+"px";
                let width = canvas.width;
                let height = canvas.height;
                if (handle != undefined){
                    handle.delete();
                    handle = cv.imread(handleImg);
                    cv.resize(handle, handle, new cv.Size(canvas.height/3, canvas.height/3));
                    rotHandle.delete();
                    rotHandle = new cv.Mat(height/3, height/3, cv.CV_8UC4);
                }
                if (img != undefined){
                    img.delete();
                    img = new cv.Mat(height, width, cv.CV_8UC4);
                }
                if (course != undefined && mode > 0){
                    course.delete();
                    course = cv.imread([course1Img, course2Img, course3Img][mode-1]);
                    cv.resize(course, course, new cv.Size(height/3, height/3));
                    M = cv.getRotationMatrix2D(new cv.Point(height/6, height/6), 90, 1);
                    cv.warpAffine(course, course, M, new cv.Size(height/3, height/3), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                    let carSize = height/3*50/planeSize;
                    let checkSize = carSize*0.6;
                    red.delete();
                    red = cv.imread(redImg);
                    cv.resize(red, red, new cv.Size(checkSize, checkSize));
                    blue.delete();
                    blue = cv.imread(blueImg);
                    cv.resize(blue, blue, new cv.Size(checkSize, checkSize));
                }
            }
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize();

            let mode, operation=false;
            document.getElementById("parking").onclick = () => {
                mode = 0;
                checkNum = 0;
                start();
            };
            document.getElementById("course1").onclick = () => {
                mode = 1;
                checkNum = 4;
                start();
            };
            document.getElementById("course2").onclick = () => {
                mode = 2;
                checkNum = 5;
                start();
            };
            document.getElementById("course3").onclick = () => {
                mode = 3;
                checkNum = 6;
                start();
            };
            document.getElementById("restart").onclick = () => {
                restart();
            };

            function start(){
                localData = JSON.parse(localStorage.getItem("data"));
                if (!localData){
                    localData = new Array(100);
                    localStorage.setItem('data', JSON.stringify(localData));
                }
                else if (localData[mode*3]) {
                    document.getElementById("min").innerText = "Min : "+String(localData[mode*3].toFixed(1));
                    document.getElementById("mean").innerText = "Mean: "+String((localData[mode*3+2]/localData[mode*3+1]).toFixed(1));
                }
                if (window.parent.document.getElementById("min0")){
                    for (let i=0; i<4; i++){
                        if (localData[i*3]){
                            window.parent.document.getElementById("min"+String(i)).innerText = "　最短: "+String(localData[i*3].toFixed(1));
                            window.parent.document.getElementById("mean"+String(i)).innerText = "　平均: "+String((localData[i*3+2]/localData[i*3+1]).toFixed(1));
                        }
                        else {
                            window.parent.document.getElementById("min"+String(i)).innerText = "　最短: ";
                            window.parent.document.getElementById("mean"+String(i)).innerText = "　平均: ";
                        }
                    }
                }
                document.getElementById("parking").style.display = "none";
                document.getElementById("course1").style.display = "none";
                document.getElementById("course2").style.display = "none";
                document.getElementById("course3").style.display = "none";
                document.getElementById("restart").style.display = "";
                setPhy();
                setView();
                initBodyPosition.copy(phyBody.position);
                initBodyQuaternion.copy(phyBody.quaternion);
                for (let i=0; i<4; i++){
                    initWheelPosition[i].copy(phyWheels[i].position);
                    initWheelQuaternion[i].copy(phyWheels[i].quaternion);
                }
                if (mode == 0)    createTarget();
                animate();
            }

            function end(){
                localData = JSON.parse(localStorage.getItem("data"));
                if (localData[mode*3]){
                    if (time < localData[mode*3]){
                        localData[mode*3] = time;
                    }
                    localData[mode*3+1]++;
                    localData[mode*3+2] += time;
                }
                else {
                    localData[mode*3] = time;
                    localData[mode*3+1] = 1;
                    localData[mode*3+2] = time;
                }
                document.getElementById("min").innerText = "Min : "+String(localData[mode*3].toFixed(1));
                document.getElementById("mean").innerText = "Mean: "+String((localData[mode*3+2]/localData[mode*3+1]).toFixed(1));
                if (window.parent.document.getElementById("min0")){
                    for (let i=0; i<4; i++){
                        if (localData[i*3]){
                            window.parent.document.getElementById("min"+String(i)).innerText = "　最短: "+String(localData[i*3].toFixed(1));
                            window.parent.document.getElementById("mean"+String(i)).innerText = "　平均: "+String((localData[i*3+2]/localData[i*3+1]).toFixed(1));
                        }
                        else {
                            window.parent.document.getElementById("min"+String(i)).innerText = "　最短: ";
                            window.parent.document.getElementById("mean"+String(i)).innerText = "　平均: ";
                        }
                    }
                }
                localStorage.setItem('data', JSON.stringify(localData));
                time = 0;
                document.getElementById("time").innerText = "Time: "+String(time.toFixed(1));
                if (mode != 0){
                    phyBody.position.copy(initBodyPosition);
                    phyBody.quaternion.copy(initBodyQuaternion);
                    phyBody.velocity = new CANNON.Vec3(0, 0, 0);
                    for (let i=0; i<4; i++){
                        phyWheels[i].position.copy(initWheelPosition[i]);
                        phyWheels[i].quaternion.copy(initWheelQuaternion[i]);
                        phyWheels[i].velocity = new CANNON.Vec3(0, 0, 0);
                    }
                }
                for (let i=0; i<checkNum; i++){
                    viewCheck[i].visible = true;
                }
            }

            function restart(){
                location.reload(false);
            }

            function draw(){
                if (!operation){
                    operation = true;
                    document.getElementById("loading").style.display = "none";
                }
                let width = canvas2.width;
                let height = canvas2.height;
                
                if (img == undefined){
                    img = new cv.Mat(height, width, cv.CV_8UC4);
                }
                if (handle == undefined){
                    handle = cv.imread(handleImg);
                    cv.resize(handle, handle, new cv.Size(height/3, height/3));
                    rotHandle = new cv.Mat(height/3, height/3, cv.CV_8UC4);
                }
                let M = cv.getRotationMatrix2D(new cv.Point(height/6, height/6), -wheelAngle*360/Math.PI, 1);
                cv.warpAffine(handle, rotHandle, M, new cv.Size(height/3, height/3), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                let roi = img.roi(new cv.Rect(width*2/3-height/3, height*2/3, height/3, height/3));
                rotHandle.copyTo(roi);
                roi.delete();
                
                if (mode > 0){
                    let carSize = height/3*50/planeSize;
                    let checkSize = carSize*0.6;
                    let img2 = new cv.Mat(height, width, cv.CV_8UC4, new cv.Scalar());
                    if (course == undefined){
                        course = cv.imread([course1Img, course2Img, course3Img][mode-1]);
                        cv.resize(course, course, new cv.Size(height/3, height/3));
                        M = cv.getRotationMatrix2D(new cv.Point(height/6, height/6), 90, 1);
                        cv.warpAffine(course, course, M, new cv.Size(height/3, height/3), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                        area = cv.imread([area1Img, area2Img, area3Img][mode-1]);
                        red = cv.imread(redImg);
                        cv.resize(red, red, new cv.Size(checkSize, checkSize));
                        blue = cv.imread(blueImg);
                        cv.resize(blue, blue, new cv.Size(checkSize, checkSize));
                    }
                    roi = img2.roi(new cv.Rect(height/3*(3.5/9), height*2/3, height/3, height/3));
                    course.copyTo(roi);
                    roi.delete();

                    function paste(src, dst, x, y){
                        for (let i=0; i<src.rows; i++){
                            for (let j=0; j<src.cols; j++){
                                if (src.ucharPtr(i, j)[3] != 0){
                                    dst.ucharPtr(y+i, x+j)[0] = src.ucharPtr(i, j)[0];
                                    dst.ucharPtr(y+i, x+j)[1] = src.ucharPtr(i, j)[1];
                                    dst.ucharPtr(y+i, x+j)[2] = src.ucharPtr(i, j)[2];
                                }
                            }
                        }
                    }

                    for (let i=0; i<checkNum-1; i++){
                        if (viewCheck[i].visible){
                            paste(red, img2, height/3*(CheckPosition[i][1]/planeSize+0.5+3.5/9)-checkSize/2, height-height/3*(CheckPosition[i][0]/planeSize+0.5)-checkSize/2);
                        }
                    }
                    if (viewCheck[checkNum-1].visible){
                        paste(blue, img2, height/3*(CheckPosition[checkNum-1][1]/planeSize+0.5+3.5/9)-checkSize/2, height-height/3*(CheckPosition[checkNum-1][0]/planeSize+0.5)-checkSize/2);
                    }

                    let x, y;
                    x = viewCar.position.z/planeSize+0.5;
                    y = -viewCar.position.x/planeSize+0.5;
                    if (0 < x && x < 1 && 0 < y && y < 1){
                        carMode = area.ucharPtr(x*area.rows, (1-y)*area.cols);
                        if (carMode[0] == 255){
                            carMode = 1;
                            speedUp = Date.now();
                        }
                        else if (carMode[1] == 255){
                            carMode = 2;
                        }
                        else if (carMode[2] == 255){
                            carMode = 3;
                        }
                        else {
                            carMode = 0;
                        }
                    }
                    else {
                        carMode = 2;
                    }

                    if (Date.now()-speedUp < 3000){
                        for (let i=4; i<8; i++){
                            viewWheels[i].material.color.set(0xffff00);
                        }
                    }
                    else if (carMode == 0){
                        for (let i=4; i<8; i++){
                            viewWheels[i].material.color.set(0xaaaaaa);
                        }
                    }
                    else if (carMode == 2){
                        for (let i=4; i<8; i++){
                            viewWheels[i].material.color.set(0x33aa33);
                        }
                    }
                    else if (carMode == 3){
                        for (let i=4; i<8; i++){
                            viewWheels[i].material.color.set(0x00bbbb);
                        }
                    }

                    let forward = new THREE.Vector4(1, 0, 0, 0);
                    forward.applyMatrix4(viewCar.matrix).normalize();
                    let carAngle = Math.atan2(-forward.z, forward.x);
                    let car = cv.imread(carImg);
                    cv.resize(car, car, new cv.Size(carSize, carSize));
                    M = cv.getRotationMatrix2D(new cv.Point(carSize/2, carSize/2), carAngle*180/Math.PI-90, 1);
                    cv.warpAffine(car, car, M, new cv.Size(carSize, carSize), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                    //roi = img.roi(new cv.Rect(height/3*(x+3.5/9), height*(2/3+y/3), carSize, carSize));
                    paste(car, img2, height/3*(x+3.5/9)-carSize/2, height*(2/3+y/3)-carSize/2);
                    car.delete();
                    
                    cv.imshow("canvas3", img2);
                    img2.delete();
                }

                let speed = clamp(-wheelSpeed/5, -1, 1);
                let color = (speed => {
                    if (speed < -0.5)        return [255, speed*512+512, 0, 255];
                    else if (speed < 0)      return [-speed*512, 255, 0, 255];
                    else if (speed < 0.5)    return [0, 255, speed*512, 255];
                    else                     return [0, -speed*512+512, 255, 255];
                })(speed);
                cv.rectangle(img, new cv.Point(width*(17/48), height*(5/6+speed/6-0.01)), new cv.Point(width*(22/48), height*(5/6+speed/6+0.01)), color, cv.FILLED);
                cv.ellipse(img, new cv.Point(width*(40/48), height*(5/6)), new cv.Size(height/6, height/6), 0, 270-targetRatio, 270, [0, 0, 255, 255], cv.FILLED);
                cv.imshow("canvas2", img);
            }

            if (navigator.userAgent.match(/iPhone|Android.+Mobile/)){
                if (typeof DeviceMotionEvent.requestPermission === 'function'){
                    (async () => await DeviceMotionEvent.requestPermission())();
                }
                timeStep = 1/10;
                window.addEventListener("devicemotion", e => {
                    let accVec = e.accelerationIncludingGravity;
                    let [x, y, z] = [accVec.x, accVec.y, accVec.z];
                    let angle = Math.atan(y/x);
                    let maxSpeed = 5;
                    if (mode == 0)    maxSpeed = 2;
                    if (carMode == 0){
                        wheelAngle = clamp(-2*angle, -0.75, 0.75);
                        wheelSpeed = clamp(z, -maxSpeed, maxSpeed);
                    }
                    else if (carMode == 1){
                        wheelAngle = clamp(-2*angle, -0.75, 0.75);
                        wheelSpeed = clamp(z, -maxSpeed, maxSpeed);
                    }
                    else if (carMode == 2){
                        wheelAngle = clamp(-2*angle, -0.75, 0.75);
                        wheelSpeed = clamp(z, -maxSpeed/2, maxSpeed/2);
                    }
                    else if (carMode == 3){
                        wheelAngle = clamp(-2*angle, -0.75, 0.75);
                        wheelSpeed = clamp(z, -maxSpeed, maxSpeed);
                        phyBody.angularVelocity = new CANNON.Vec3(0, angle*Math.sign(wheelSpeed), 0);
                    }
                    if (Date.now()-speedUp < 3000){
                        wheelSpeed *= 2;
                    }
                });
                setInterval(() => {
                    let width = canvas2.width;
                    let height = canvas2.height;
                    if (img != undefined){
                        img.delete();
                        img = new cv.Mat.zeros(height, width, cv.CV_8UC4);
                    }
                    draw();
                }, 200);
                operation = true;
            }
            else {
                const video = document.getElementById("video");
                video.style.display = "none";

                function onResults(results) {
                    let width = canvas2.width;
                    let height = canvas2.height;
                    if (img == undefined){
                        img = new cv.Mat(height, width, cv.CV_8UC4);
                    }
                    context2.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, width, height);
                    img.data.set(context2.getImageData(0, 0, width, height).data);
                    context2.clearRect(0, 0, width, height);
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length == 2) {
                        let sumx = [0, 0], sumy = [0, 0], avgx = [0, 0], avgy = [0, 0];
                        results.multiHandLandmarks.forEach((landmarks, index) => {
                            landmarks.forEach(point => {
                                p = new cv.Point(width*point.x, height*point.y);
                                cv.circle(img, p, width/100, [255, 0, 0, 255], cv.FILLED);
                                // 手の中心点を求める。
                                const {x, y} = point;
                                sumx[index] = sumx[index] + width*x;
                                sumy[index] = sumy[index] + height*y;
                            });
                            avgx[index] = Math.floor(sumx[index] / landmarks.length);
                            avgy[index] = Math.floor(sumy[index] / landmarks.length);
                            let avgp = new cv.Point(avgx[index], avgy[index])
                            cv.circle(img, avgp, width/100, [0, 0, 255, 255], cv.FILLED);
                        });
                        // 中心との角度計算
                        let center = [(avgx[0]+avgx[1])/2, (avgy[0]+avgy[1])/2];
                        let angle;
                        if (avgx[0] > avgx[1]){
                            angle = Math.atan2(avgy[0] - center[1], avgx[0] - center[0]);
                        }
                        else {
                            angle = Math.atan2(avgy[1] - center[1], avgx[1] - center[0]);
                        }
                        let handSizes = [0, 0];
                        let diff = (x1, y1, x2, y2) => {return ((x1-x2)**2+(y1-y2)**2)**0.5};
                        results.multiHandLandmarks.forEach((landmarks, index) => {
                            landmarks.forEach(point => {
                                handSizes[index] = Math.max(handSizes[index], diff(avgx[index], avgy[index], width*point.x, height*point.y));
                            });
                        });
                        let handSize = (handSizes[0]+handSizes[1])/2;
                        let maxSpeed = 5;
                        if (mode == 0)    maxSpeed = 2;
                        if (carMode == 0){
                            wheelAngle = angle/2;
                            wheelSpeed = clamp(70*(handSize/width-0.12), -maxSpeed, maxSpeed);
                        }
                        else if (carMode == 1){
                            wheelAngle = angle/2;
                            wheelSpeed = clamp(70*(handSize/width-0.12), -maxSpeed, maxSpeed);
                        }
                        else if (carMode == 2){
                            wheelAngle = angle/2;
                            wheelSpeed = clamp(70*(handSize/width-0.12), -maxSpeed/2, maxSpeed/2);
                        }
                        else if (carMode == 3){
                            wheelAngle = angle/2;
                            wheelSpeed = clamp(70*(handSize/width-0.12), -maxSpeed, maxSpeed);
                            phyBody.angularVelocity = new CANNON.Vec3(0, angle*Math.sign(wheelSpeed), 0);
                        }
                        if (Date.now()-speedUp < 3000){
                            wheelSpeed *= 2;
                        }
                    }
                    else {
                        wheelAngle *= 0.95;
                        wheelSpeed *= 0.95;
                    }
                    let M = cv.matFromArray(2, 3, cv.CV_64FC1, [1/3, 0, 0, 0, 1/3, height*2/3]);
                    let dsize = new cv.Size(width, height);
                    cv.warpAffine(img, img, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                    draw();
                }

                const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.1.1617147326/${file}`;
                }});
                hands.setOptions({
                    maxNumHands: 2,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                hands.onResults(onResults);

                let flag = 0;
                const cameraDevice = new Camera(video, {
                    onFrame: async () => {
                        flag++;
                        if (flag%10 == 0){
                            await hands.send({image: video});
                        }
                    },
                    width: 1280,
                    height: 720
                });
                cameraDevice.start();
            }

            // 物理エンジンの設定
            function setPhy() {
                wheelAngle = 0;
                wheelSpeed = 0;
                // 物理世界を生成
                world = new CANNON.World();
                // 重力を設定
                world.gravity.set(0, -9.82, 0);
                // ぶつかっている「可能性のある」剛体同士を見つける作業
                world.broadphase = new CANNON.NaiveBroadphase();
                // 反復計算回数
                world.solver.iterations = 10;
                // 許容値
                world.solver.tolerance = 0.1;

                let mat = new CANNON.Material('mat');
                mat.friction = 1.0;
                mat.restitution = 0.5;

                // 地面用にPlaneの剛体を質量0で生成
                phyPlane = new CANNON.Body({mass: 0});
                phyPlane.material = mat;
                phyPlane.addShape(new CANNON.Plane());
                // X軸に90度に回転
                phyPlane.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);
                // 物理世界に追加
                world.add(phyPlane);

                // Boxのシェイプの剛体を質量10で生成
                phyBody = new CANNON.Body({mass: 10});
                phyBody.material = mat;
                phyBody.addShape(new CANNON.Box(new CANNON.Vec3(phyBodySize[0]/2, phyBodySize[1]/2, phyBodySize[2]/2)));
                phyBody.position.y = 10;
                // 物理世界に追加
                world.add(phyBody);

                phyCar = new CANNON.Body({
                    mass: 10,
                    collisionFilterGroup: 2,
                    collisionFilterMask: 2
                });
                phyCar.material = mat;
                phyCar.addShape(new CANNON.Box(new CANNON.Vec3(carSize[0]/2, carSize[1]/2, carSize[2]/2)));
                phyCar.position.y = 10;
                // 物理世界に追加
                world.add(phyCar);

                // 車輪の生成
                // 0: 前左, 1: 前右
                // 2: 後左, 3: 後右
                for (var i=0; i<4; i++){
                    phyWheels[i] = new CANNON.Body({mass: 1});
                    phyWheels[i].mat = mat;
                    phyWheels[i].addShape(new CANNON.Cylinder(wheelSize[0], wheelSize[0], wheelSize[1], 100));
                    if (i < 2)    phyWheels[i].position.x = phyBodySize[0]/2-wheelSize[0]/2;
                    else          phyWheels[i].position.x = -(phyBodySize[0]/2-wheelSize[0]/2);
                    phyWheels[i].position.y = 10-phyBodySize[1]/2+wheelSize[0]/2;
                    if (i%2 == 0)    phyWheels[i].position.z = -(phyBodySize[2]/2+wheelSize[1]/2+2);
                    else             phyWheels[i].position.z = phyBodySize[2]/2+wheelSize[1]/2+2;
                    world.add(phyWheels[i]);
                }

                // 本体と車輪の拘束を設定
                let zero = new CANNON.Vec3();
                constraints.push(new CANNON.HingeConstraint(phyBody, phyWheels[0],  {pivotA: new CANNON.Vec3(phyBodySize[0]/2-wheelSize[0]/2, -phyBodySize[1]/2+wheelSize[0]/2, -(phyBodySize[2]/2+wheelSize[1]/2+2)), axisA: new CANNON.Vec3(0, 0, 1),  pivotB: zero, axisB: new CANNON.Vec3(0, 0, 1)}));
                constraints.push(new CANNON.HingeConstraint(phyBody, phyWheels[1],  {pivotA: new CANNON.Vec3(phyBodySize[0]/2-wheelSize[0]/2, -phyBodySize[1]/2+wheelSize[0]/2, phyBodySize[2]/2+wheelSize[1]/2+2), axisA: new CANNON.Vec3(0, 0, 1),  pivotB: zero, axisB: new CANNON.Vec3(0, 0, 1)}));
                constraints.push(new CANNON.HingeConstraint(phyBody, phyWheels[2],  {pivotA: new CANNON.Vec3(-(phyBodySize[0]/2-wheelSize[0]/2), -phyBodySize[1]/2+wheelSize[0]/2, -(phyBodySize[2]/2+wheelSize[1]/2+2)), axisA: new CANNON.Vec3(0, 0, 1),  pivotB: zero, axisB: new CANNON.Vec3(0, 0, 1)}));
                constraints.push(new CANNON.HingeConstraint(phyBody, phyWheels[3],  {pivotA: new CANNON.Vec3(-(phyBodySize[0]/2-wheelSize[0]/2), -phyBodySize[1]/2+wheelSize[0]/2, phyBodySize[2]/2+wheelSize[1]/2+2), axisA: new CANNON.Vec3(0, 0, 1),  pivotB: zero, axisB: new CANNON.Vec3(0, 0, 1)}));
                for (let i=0; i<4; i++){
                    world.addConstraint(constraints[i]);
                }
                // 前輪で駆動
                constraints[0].enableMotor();
                constraints[1].enableMotor();

                if (mode != 0){
                    for (let i=0; i<checkNum; i++){
                        phyCheck[i] = new CANNON.Body({
                            mass: 0,
                            collisionFilterGroup: 2,
                            collisionFilterMask: 2
                        });
                        phyCheck[i].mat =  mat;
                        phyCheck[i].addShape(new CANNON.Sphere(4));
                        phyCheck[i].collisionResponse = 0;
                        world.add(phyCheck[i]);
                        phyCheck[i].addEventListener("collide", e => {
                            let index = -1;
                            for (let i=0; i<checkNum; i++){
                                if (e.body.id == phyCheck[i].id || e.target.id == phyCheck[i].id){
                                    index = i;
                                    break;
                                }
                            }
                            if (index != -1){
                                viewCheck[index].visible = false;
                                let cleared = true;
                                for (let i=0; i<checkNum; i++){
                                    cleared &&= (!viewCheck[i].visible);
                                }
                                if (cleared){
                                    end();
                                }
                            }
                        });
                    }
                }
            }

            // CGの設定
            function setView() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(45, canvas.width/canvas.height, 0.1, 1000);
                camera.position.set(-60, 60, -60);
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                scene.add(camera);

                let directionalLight = new THREE.DirectionalLight(0xffffff);
                directionalLight.position.set(-100, 100, 100);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.set(4096, 4096);
                directionalLight.shadow.camera.near = 2;
                directionalLight.shadow.camera.far = 10000;
                directionalLight.shadow.camera.left = -500;
                directionalLight.shadow.camera.right = 500;
                directionalLight.shadow.camera.top = 500;
                directionalLight.shadow.camera.bottom = -500;
                scene.add(directionalLight);
                
                let amb = new THREE.AmbientLight(0x999999);
                scene.add(amb);

                loader.load('./img/Car.dae', (collada) => {
                    viewCar = collada.scene;
                    viewCar.scale.set(8, 8, 8);
                    viewCar.traverse(function(child) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    });
                    for (let i=0; i<collada.scene.children[0].material.length; i++){
                        collada.scene.children[0].material[i].type = "MeshPhongMaterial";
                    }
                    scene.add(viewCar);
                });

                for (var i=0; i<4; i++){
                    let geoWheel = new THREE.CylinderGeometry(wheelSize[0], wheelSize[0], wheelSize[1], 100);
                    geoWheel.rotateX(Math.PI/2);
                    viewWheels[i] = new THREE.Mesh(geoWheel, new THREE.MeshLambertMaterial({
                        color: 0x000000
                    }));
                    viewWheels[i].castShadow = true;
                    viewWheels[i].receiveShadow = true;
                    scene.add(viewWheels[i]);

                    geoWheel = new THREE.CylinderGeometry(0.6*wheelSize[0], 0.6*wheelSize[0], wheelSize[1]*1.1, 100);
                    geoWheel.rotateX(Math.PI/2);
                    viewWheels[i+4] = new THREE.Mesh(geoWheel, new THREE.MeshLambertMaterial({
                        color: 0xaaaaaa
                    }));
                    viewWheels[i+4].castShadow = true;
                    viewWheels[i+4].receiveShadow = true;
                    scene.add(viewWheels[i+4]);
                }

                /*
                viewBody = new THREE.Mesh(new THREE.CubeGeometry(phyBodySize[0], phyBodySize[1], phyBodySize[2], 10, 10), new THREE.MeshLambertMaterial({
                    color: 0xff00ff
                }));
                viewBody.castShadow = true;
                viewBody.receiveShadow = true;
                scene.add(viewBody);
                */

                if (mode == 0){
                    loader.load('./img/Car.dae', (collada) => {
                        targetBody = collada.scene;
                        targetBody.scale.set(8, 8, 8);
                        for (let i=0; i<collada.scene.children[0].material.length; i++){
                            collada.scene.children[0].material[i].opacity = 0.5;
                            collada.scene.children[0].material[i].transparent = true;
                        }
                        scene.add(targetBody);
                    });
                    /*
                    targetBody = new THREE.Mesh(new THREE.CubeGeometry(phyBodySize[0], phyBodySize[1], phyBodySize[2], 10, 10), new THREE.MeshLambertMaterial({
                        color: 0xff00ff,
                        opacity: 0.5,
                        transparent: true
                    }));
                    scene.add(targetBody);
                    */
                    for (var i=0; i<4; i++){
                        let geoWheel = new THREE.CylinderGeometry(wheelSize[0], wheelSize[0], wheelSize[1], 100);
                        geoWheel.rotateX(Math.PI/2);
                        targetWheels[i] = new THREE.Mesh(geoWheel, new THREE.MeshLambertMaterial({
                            color: 0x000000,
                            opacity: 0.5,
                            transparent: true
                        }));
                        scene.add(targetWheels[i]);

                        geoWheel = new THREE.CylinderGeometry(0.6*wheelSize[0], 0.6*wheelSize[0], wheelSize[1]*1.1, 100);
                        geoWheel.rotateX(Math.PI/2);
                        targetWheels[i+4] = new THREE.Mesh(geoWheel, new THREE.MeshLambertMaterial({
                            color: 0xaaaaaa,
                            opacity: 0.5,
                            transparent: true
                        }));
                        scene.add(targetWheels[i+4]);
                    }
                }

                textureFile = ["img/check.png", "img/Course1.png", "img/Course2.png", "img/Course3.png"][mode];
                planeSize = [160, 250, 300, 400][mode];
                carPosition = [[0, 0], [-102, -85], [-130, -109], [-176, -158]][mode];
                CheckPosition = [undefined,
                    [[-14, -82], [82, -82], [82, 18], [82, 100]],
                    [[-42, -109], [55, -55], [-133, 0], [39, 93], [-133, 109]],
                    [[15, -156], [76, -82], [4, -29], [-83, 67], [107, 67], [177, 160]]
                ][mode];
                phyBody.position.vadd(new CANNON.Vec3(carPosition[0], 0, carPosition[1]), phyBody.position);
                for (let i=0; i<4; i++){
                    phyWheels[i].position.vadd(new CANNON.Vec3(carPosition[0], 0, carPosition[1]), phyWheels[i].position);
                }
                for (let i=0; i<checkNum; i++){
                    phyCheck[i].position.set(CheckPosition[i][0], 0, CheckPosition[i][1]);
                }

                let texture = new THREE.TextureLoader().load(textureFile);
                viewPlane = new THREE.Mesh(new THREE.PlaneGeometry(planeSize, planeSize), new THREE.MeshPhongMaterial({
                    map: texture
                }));
                viewPlane.rotation.x = -Math.PI/2;
                viewPlane.receiveShadow = true;
                scene.add(viewPlane);

                if (mode != 0){
                    for (let i=0; i<checkNum; i++){
                        loader.load('./img/CheckPoint.dae', (collada) => {
                            viewCheck[i] = collada.scene;
                            viewCheck[i].scale.set(0.1, 0.1, 0.1);
                            viewCheck[i].traverse(function(child) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            });
                            collada.scene.children[0].material = new THREE.MeshStandardMaterial({
                                color: (i != checkNum-1 ? 0xff0000 : 0x0040ff),
                                roughness: 0.8,
                                metalness: 0.2,
                                opacity: 0.7,
                                transparent: true
                            });
                            scene.add(viewCheck[i]);
                        });
                    }
                }
                
                renderer = new THREE.WebGLRenderer({canvas: canvas});
                renderer.setSize(canvas.width, canvas.height);
                renderer.setClearColor(0x87ceeb);
                renderer.shadowMap.enabled = true;
                renderer.render(scene, camera);
            }
            
            // 手の検出
            // 物理エンジンを1ステップ進める→CGに反映
            // を繰り返す
            function animate(){
                document.getElementById("time").innerText = "Time: "+String(time.toFixed(1));
                if (document.getElementById("restart").style.display != "none"){
                    setTimeout(animate, 20);
                }
                //requestAnimationFrame(animate);
                // 物理エンジンの時間を進める
                if (operation){
                    world.step(timeStep);
                    time += 0.02;
                    if (time == 0.02){
                        document.getElementById("time").style.display = "";
                        document.getElementById("min").style.display = "";
                        document.getElementById("mean").style.display = "";
                        document.getElementById("reset").style.display = "";
                        document.getElementById("reset").onclick = () => {
                            localData = JSON.parse(localStorage.getItem("data"));
                            for (let i=0; i<3; i++){
                                localData[mode*3+i] = undefined;
                            }
                            localStorage.setItem('data', JSON.stringify(localData));
                            document.getElementById("min").innerText = "Min : ";
                            document.getElementById("mean").innerText = "Mean: ";
                            if (window.parent.document.getElementById("min0")){
                                for (let i=0; i<4; i++){
                                    if (localData[i*3]){
                                        window.parent.document.getElementById("min"+String(i)).innerText = "　最短: "+String(localData[i*3].toFixed(1));
                                        window.parent.document.getElementById("mean"+String(i)).innerText = "　平均: "+String((localData[i*3+2]/localData[i*3+1]).toFixed(1));
                                    }
                                    else {
                                        window.parent.document.getElementById("min"+String(i)).innerText = "　最短: ";
                                        window.parent.document.getElementById("mean"+String(i)).innerText = "　平均: ";
                                    }
                                }
                            }
                            return;
                        };
                    }
                }
                
                /*
                viewBody.position.copy(phyBody.position);
                viewBody.quaternion.copy(phyBody.quaternion);
                */

                phyCar.position.copy(phyBody.position);
                phyCar.quaternion.copy(phyBody.quaternion);
                
                viewCar.position.copy(phyBody.position);
                viewCar.quaternion.copy(phyBody.quaternion);

                let rot = new THREE.Quaternion();
                rot.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI/2);
                viewCar.quaternion.multiply(rot);
                rot.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI/2);
                viewCar.quaternion.multiply(rot);
                viewCar.position.add(new THREE.Vector3(0, -5, 0));
                
                for (let i=0; i<4; i++){
                    viewWheels[i].position.copy(phyWheels[i].position);
                    viewWheels[i].quaternion.copy(phyWheels[i].quaternion);
                    viewWheels[i+4].position.copy(phyWheels[i].position);
                    viewWheels[i+4].quaternion.copy(phyWheels[i].quaternion);
                }
                
                if (mode != 0){
                    for (let i=0; i<checkNum; i++){
                        viewCheck[i].position.copy(phyCheck[i].position);
                        if (operation){
                            rot = new THREE.Quaternion();
                            rot.setFromAxisAngle(new THREE.Vector3(0, 0, 1), 0.05);
                            viewCheck[i].quaternion.multiply(rot);
                        }
                    }
                }
                else {
                    let maxDist = 0;
                    for (let i=0; i<4; i++){
                        maxDist = Math.max(maxDist, ((x1, y1, x2, y2) => {
                            return ((x1-x2)**2+(y1-y2)**2)**0.5;
                        })(viewWheels[i].position.x, viewWheels[i].position.z, targetWheels[i].position.x, targetWheels[i].position.z));
                    }
                    targetRatio += Math.floor(20/maxDist);
                    if (targetRatio > 360){
                        targetRatio = 0;
                        end();
                        createTarget();
                    }
                }

                // 前方ベクトルの計算
                let forward = new THREE.Vector4(1, 0, 0, 0);
                forward.applyMatrix4(viewCar.matrix).normalize();

                /*
                let ratio = 0.9;
                camera.position.multiplyScalar(ratio);
                camera.position.add(viewCar.position.clone().add(new THREE.Vector3(-80*forward.x, 50, -80*forward.z)).multiplyScalar(1-ratio));
                */
                camera.position.set(viewCar.position.x-60, viewCar.position.y+60, viewCar.position.z-60);
                camera.lookAt(viewCar.position);
                
                // 前輪で操舵
                constraints[0].axisA = new CANNON.Vec3(Math.sin(wheelAngle), 0, Math.cos(wheelAngle));
                constraints[1].axisA = new CANNON.Vec3(Math.sin(wheelAngle), 0, Math.cos(wheelAngle));
                constraints[0].setMotorSpeed(wheelSpeed);
                constraints[1].setMotorSpeed(wheelSpeed);
                // レンダリング
                renderer.render(scene, camera);
            }

            function createTarget(){
                if (targetBody == undefined){
                    setTimeout(createTarget, 100);
                    return;
                }
                
                targetPosition = [10*Math.floor(Math.random()*7)-30, 10*Math.floor(Math.random()*7)-30];
                targetDirection = Math.floor(Math.random()*4);
                targetBody.position.set(targetPosition[0], phyBodySize[1]/2+wheelSize[0]/2, targetPosition[1]);
                
                let rot = new THREE.Quaternion();
                if (targetQuaternions[0] == undefined){
                    for (let i=0; i<4; i++){
                        rot.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI/2);
                        targetBody.quaternion.multiply(rot);
                        targetQuaternions[i] = targetBody.quaternion.clone();
                    }
                }
                targetBody.quaternion.copy(targetQuaternions[targetDirection]);
                targetBody.position.add(new THREE.Vector3(0, -5, 0));

                for (let i=0; i<4; i++){
                    if (targetDirection%2 == 1){
                        targetWheels[i].rotation.set(0, Math.PI/2, 0);
                    }
                    else {
                        targetWheels[i].rotation.set(0, 0, 0);
                    }
                    if (i < 2)    targetWheels[i].position.x = phyBodySize[0]/2-wheelSize[0]/2;
                    else          targetWheels[i].position.x = -(phyBodySize[0]/2-wheelSize[0]/2);
                    if (i%2 == 0)    targetWheels[i].position.z = -(phyBodySize[2]/2+wheelSize[1]/2+2);
                    else             targetWheels[i].position.z = phyBodySize[2]/2+wheelSize[1]/2+2;
                    if (targetDirection == 1){
                        [targetWheels[i].position.x, targetWheels[i].position.z] = [targetWheels[i].position.z, -targetWheels[i].position.x]
                    }
                    else if (targetDirection == 2){
                        targetWheels[i].position.x = -targetWheels[i].position.x;
                        targetWheels[i].position.z = -targetWheels[i].position.z;
                    }
                    else if (targetDirection == 3){
                        [targetWheels[i].position.x, targetWheels[i].position.z] = [-targetWheels[i].position.z, targetWheels[i].position.x]
                    }
                    targetWheels[i].position.add(targetBody.position);
                    targetWheels[i].position.y = wheelSize[0];

                    targetWheels[i+4].position.copy(targetWheels[i].position);
                    targetWheels[i+4].quaternion.copy(targetWheels[i].quaternion);
                }
            }
        </script>
    </body>
</html>